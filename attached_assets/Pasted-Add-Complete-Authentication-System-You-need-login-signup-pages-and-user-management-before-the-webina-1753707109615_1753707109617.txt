Add Complete Authentication System
You need login/signup pages and user management before the webinar system can work properly.

ðŸ¤– Replit AI Agent Prompt: Complete Authentication System
text
Create a complete user authentication system with login, signup, and user management:

STEP 1 - INSTALL AUTHENTICATION DEPENDENCIES:
Install these packages:
- next-auth (for authentication)
- @next-auth/prisma-adapter (database adapter)
- bcryptjs (password hashing)
- @next-auth/providers (authentication providers)

STEP 2 - UPDATE DATABASE SCHEMA:
Update schema.prisma to include NextAuth tables and user authentication:

generator client {
provider = "prisma-client-js"
}

datasource db {
provider = "postgresql"
url = env("DATABASE_URL")
}

// NextAuth.js required tables
model Account {
id String @id @default(cuid())
userId String
type String
provider String
providerAccountId String
refresh_token String? @db.Text
access_token String? @db.Text
expires_at Int?
token_type String?
scope String?
id_token String? @db.Text
session_state String?

user User @relation(fields: [userId], references: [id], onDelete: Cascade)

@@unique([provider, providerAccountId])
}

model Session {
id String @id @default(cuid())
sessionToken String @unique
userId String
expires DateTime
user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
identifier String
token String @unique
expires DateTime

@@unique([identifier, token])
}

// Updated User model with authentication
model User {
id String @id @default(cuid())
name String?
email String @unique
emailVerified DateTime?
image String?
password String? // For email/password auth
role Role @default(ATTENDEE)
profileData Json?
settings Json?
createdAt DateTime @default(now())
updatedAt DateTime @updatedAt

// Relations
accounts Account[]
sessions Session[]
hostedWebinars Webinar[] @relation("WebinarHost")
registrations Registration[]
attendance Attendance[]
}

// Rest of your existing models (Webinar, Registration, etc.)
// ... keep all your existing webinar models unchanged

enum Role {
ADMIN
HOST
CO_HOST
PANELIST
ATTENDEE
}

text

STEP 3 - CONFIGURE NEXTAUTH:
Create /app/api/auth/[...nextauth]/route.ts:

import NextAuth from 'next-auth'
import { PrismaAdapter } from '@next-auth/prisma-adapter'
import CredentialsProvider from 'next-auth/providers/credentials'
import GoogleProvider from 'next-auth/providers/google'
import { prisma } from '@/lib/db'
import bcrypt from 'bcryptjs'

const handler = NextAuth({
adapter: PrismaAdapter(prisma),
providers: [
// Email/Password Authentication
CredentialsProvider({
name: 'credentials',
credentials: {
email: { label: 'Email', type: 'email' },
password: { label: 'Password', type: 'password' }
},
async authorize(credentials) {
if (!credentials?.email || !credentials?.password) {
throw new Error('Invalid credentials')
}

text
    const user = await prisma.user.findUnique({
      where: { email: credentials.email }
    })

    if (!user || !user.password) {
      throw new Error('Invalid credentials')
    }

    const isPasswordValid = await bcrypt.compare(
      credentials.password,
      user.password
    )

    if (!isPasswordValid) {
      throw new Error('Invalid credentials')
    }

    return {
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    }
  }
}),

// Google OAuth (optional)
GoogleProvider({
  clientId: process.env.GOOGLE_CLIENT_ID!,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
}),
],
session: {
strategy: 'jwt',
},
callbacks: {
async jwt({ token, user }) {
if (user) {
token.role = user.role
token.id = user.id
}
return token
},
async session({ session, token }) {
if (token) {
session.user.id = token.id as string
session.user.role = token.role as string
}
return session
},
},
pages: {
signIn: '/auth/signin',
signUp: '/auth/signup',
},
})

export { handler as GET, handler as POST }

text

STEP 4 - CREATE SIGNUP API:
Create /app/api/auth/signup/route.ts:

import { NextRequest } from 'next/server'
import bcrypt from 'bcryptjs'
import { prisma } from '@/lib/db'

export async function POST(request: NextRequest) {
try {
const { name, email, password, role = 'HOST' } = await request.json()

text
// Validate input
if (!name || !email || !password) {
  return Response.json(
    { error: 'Name, email, and password are required' },
    { status: 400 }
  )
}

// Check if user already exists
const existingUser = await prisma.user.findUnique({
  where: { email }
})

if (existingUser) {
  return Response.json(
    { error: 'User with this email already exists' },
    { status: 400 }
  )
}

// Hash password
const hashedPassword = await bcrypt.hash(password, 12)

// Create user
const user = await prisma.user.create({
  data: {
    name,
    email,
    password: hashedPassword,
    role: role.toUpperCase(),
  }
})

// Remove password from response
const { password: _, ...userWithoutPassword } = user

return Response.json({
  user: userWithoutPassword,
  message: 'User created successfully'
})
} catch (error) {
console.error('Signup error:', error)
return Response.json(
{ error: 'Internal server error' },
{ status: 500 }
)
}
}

text

STEP 5 - CREATE LOGIN PAGE:
Create /app/auth/signin/page.tsx:

'use client'
import { useState } from 'react'
import { signIn, getSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function SignInPage() {
const [formData, setFormData] = useState({
email: '',
password: ''
})
const [error, setError] = useState('')
const [loading, setLoading] = useState(false)
const router = useRouter()

const handleSubmit = async (e: React.FormEvent) => {
e.preventDefault()
setLoading(true)
setError('')

text
try {
  const result = await signIn('credentials', {
    email: formData.email,
    password: formData.password,
    redirect: false,
  })

  if (result?.error) {
    setError('Invalid email or password')
  } else {
    // Check user role and redirect accordingly
    const session = await getSession()
    if (session?.user?.role === 'ADMIN' || session?.user?.role === 'HOST') {
      router.push('/dashboard')
    } else {
      router.push('/profile')
    }
  }
} catch (error) {
  setError('An error occurred during sign in')
} finally {
  setLoading(false)
}
}

return (
<div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
<div className="max-w-md w-full space-y-8">
<div>
<h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
Sign in to your account
</h2>
<p className="mt-2 text-center text-sm text-gray-600">
Or{' '}
<Link href="/auth/signup" className="font-medium text-blue-600 hover:text-blue-500">
create a new account
</Link>
</p>
</div>

text
    <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email address
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
        
        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            Password
          </label>
          <input
            id="password"
            name="password"
            type="password"
            required
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
      </div>

      <div>
        <button
          type="submit"
          disabled={loading}
          className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {loading ? 'Signing in...' : 'Sign in'}
        </button>
      </div>

      <div className="text-center">
        <button
          type="button"
          onClick={() => signIn('google')}
          className="w-full flex justify-center py-2 px-4 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          Sign in with Google
        </button>
      </div>
    </form>
  </div>
</div>
)
}

text

STEP 6 - CREATE SIGNUP PAGE:
Create /app/auth/signup/page.tsx:

'use client'
import { useState } from 'react'
import { signIn } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import Link from 'next/link'

export default function SignUpPage() {
const [formData, setFormData] = useState({
name: '',
email: '',
password: '',
confirmPassword: '',
role: 'HOST'
})
const [error, setError] = useState('')
const [loading, setLoading] = useState(false)
const router = useRouter()

const handleSubmit = async (e: React.FormEvent) => {
e.preventDefault()
setLoading(true)
setError('')

text
if (formData.password !== formData.confirmPassword) {
  setError('Passwords do not match')
  setLoading(false)
  return
}

try {
  const response = await fetch('/api/auth/signup', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      name: formData.name,
      email: formData.email,
      password: formData.password,
      role: formData.role,
    }),
  })

  const result = await response.json()

  if (!response.ok) {
    setError(result.error)
    return
  }

  // Auto sign in after successful signup
  const signInResult = await signIn('credentials', {
    email: formData.email,
    password: formData.password,
    redirect: false,
  })

  if (signInResult?.ok) {
    router.push('/dashboard')
  }
} catch (error) {
  setError('An error occurred during sign up')
} finally {
  setLoading(false)
}
}

return (
<div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
<div className="max-w-md w-full space-y-8">
<div>
<h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
Create your account
</h2>
<p className="mt-2 text-center text-sm text-gray-600">
Or{' '}
<Link href="/auth/signin" className="font-medium text-blue-600 hover:text-blue-500">
sign in to your existing account
</Link>
</p>
</div>

text
    <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-sm font-medium text-gray-700">
            Full Name
          </label>
          <input
            id="name"
            name="name"
            type="text"
            required
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
        
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email address
          </label>
          <input
            id="email"
            name="email"
            type="email"
            required
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>

        <div>
          <label htmlFor="role" className="block text-sm font-medium text-gray-700">
            Account Type
          </label>
          <select
            id="role"
            name="role"
            value={formData.role}
            onChange={(e) => setFormData({ ...formData, role: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="HOST">Host (Can create webinars)</option>
            <option value="ATTENDEE">Attendee (Can join webinars)</option>
          </select>
        </div>
        
        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            Password
          </label>
          <input
            id="password"
            name="password"
            type="password"
            required
            value={formData.password}
            onChange={(e) => setFormData({ ...formData, password: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>

        <div>
          <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
            Confirm Password
          </label>
          <input
            id="confirmPassword"
            name="confirmPassword"
            type="password"
            required
            value={formData.confirmPassword}
            onChange={(e) => setFormData({ ...formData, confirmPassword: e.target.value })}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          />
        </div>
      </div>

      <div>
        <button
          type="submit"
          disabled={loading}
          className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
        >
          {loading ? 'Creating account...' : 'Create account'}
        </button>
      </div>
    </form>
  </div>
</div>
)
}

text

STEP 7 - PROTECT DASHBOARD ROUTES:
Create /lib/auth.ts for session management:

import { getServerSession } from 'next-auth/next'
import { authOptions } from '@/app/api/auth/[...nextauth]/route'

export async function getSession() {
return await getServerSession(authOptions)
}

export async function requireAuth() {
const session = await getSession()
if (!session) {
throw new Error('Authentication required')
}
return session
}

export async function requireRole(allowedRoles: string[]) {
const session = await requireAuth()
if (!allowedRoles.includes(session.user.role)) {
throw new Error('Insufficient permissions')
}
return session
}

text

STEP 8 - UPDATE ENVIRONMENT VARIABLES:
Add to your .env.local:

NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-super-secret-nextauth-secret-key
GOOGLE_CLIENT_ID=your-google-client-id (optional)
GOOGLE_CLIENT_SECRET=your-google-client-secret (optional)

text

STEP 9 - UPDATE ROOT LAYOUT:
Update /app/layout.tsx to include SessionProvider:

import { SessionProvider } from 'next-auth/react'
import { getServerSession } from 'next-auth/next'

export default async function RootLayout({
children,
}: {
children: React.ReactNode
}) {
const session = await getServerSession()

return (
<html lang="en">
<body>
<SessionProvider session={session}>
{children}
</SessionProvider>
</body>
</html>
)
}

text

STEP 10 - UPDATE WEBINAR CREATION:
Update your webinar creation API to use authenticated user:

// In /app/api/webinars/route.ts
import { requireRole } from '@/lib/auth'

export async function POST(request: Request) {
try {
// Require user to be HOST or ADMIN
const session = await requireRole(['HOST', 'ADMIN'])

text
const data = await request.json()

// Use authenticated user's ID as hostId
const webinarData = {
  ...data,
  hostId: session.user.id // Use actual authenticated user ID
}

// Rest of your webinar creation logic...
} catch (error) {
if (error.message === 'Authentication required') {
return Response.json({ error: 'Please sign in to create webinars' }, { status: 401 })
}
if (error.message === 'Insufficient permissions') {
return Response.json({ error: 'Only hosts can create webinars' }, { status: 403 })
}
// Handle other errors...
}
}

text

STEP 11 - UPDATE DASHBOARD TO SHOW USER INFO:
Update your dashboard to show current user and add logout:

'use client'
import { useSession, signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'

export default function Dashboard() {
const { data: session, status } = useSession()
const router = useRouter()

if (status === 'loading') return <div>Loading...</div>

if (status === 'unauthenticated') {
router.push('/auth/signin')
return null
}

return (
<div>
<header className="bg-white shadow">
<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
<div className="flex justify-between items-center py-6">
<h1 className="text-3xl font-bold text-gray-900">
Welcome, {session?.user?.name}!
</h1>
<div className="flex items-center space-x-4">
<span className="text-sm text-gray-600">
Role: {session?.user?.role}
</span>
<button
onClick={() => signOut()}
className="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700"
>
Sign Out
</button>
</div>
</div>
</div>
</header>

text
  {/* Rest of your dashboard content */}
</div>
)
}

text

Now you'll have:
âœ… Complete user authentication (login/signup)
âœ… Role-based access control (HOST, ADMIN, ATTENDEE)
âœ… Protected routes and APIs
âœ… User session management
âœ… Proper user identification for webinar creation
âœ… "Start Webinar" button will work with authenticated users

Run this prompt, then create your first user account and the webinar system will work properly!